# 电网设备故障预案辅助决策智能体

本方案将 **AutoGen 中控规划调度**与 **LangGraph/Smolagents 线性执行**有机结合：

- AutoGen 专注于"读懂预案+调度执行"；
- LangGraph/Smolagents 负责"高效、可控地执行线性流程"；
- 通过预案 DSL 统一上下游接口，确保系统可扩展、可追溯。

---

## 1. 背景与需求分析

### 1.1 业务背景

- 电网调度中心需应对多类设备故障场景，必须依据《稳定规定/调度规程》快速制定故障处置方案。
- 当前流程过度依赖人工查阅预案，导致处理速度慢、容易出错且可追溯性差。
- 随着AI技术发展，我们的目标是**让大模型自动解析标准预案，编排执行步骤，调用工具/规程库，生成可追溯的决策报告**。

### 1.2 主要痛点

- **预案数量多**：几十种标准预案（直流限额、断面功率、备用容量、频率稳定等），更新频繁，人工维护成本高；
- **结构相似**：大多数预案逻辑相对固定（线性、顺序式，RAG + Tool + Compute），却仍需人工操作；
- **人工维护成本高**：每次新增或更新预案，都需人工编写代码逻辑，而调度员作为非计算机专业人员，不适合直接编写代码；
- **透明性/安全性要求高**：辅助决策系统需具备**透明性、审计性、可追溯性**，必须提供完整的推导过程和引用来源。

### 1.3 需求总结

1. **预案自然语言化**：调度专业人员只需使用规范化文本编写预案，无需编写代码。
2. **自动解析执行**：系统能将预案文本自动转换为Plan JSON（DSL），然后调用执行器运行。
3. **灵活架构**：能处理**线性顺序预案**（占大多数），同时支持复杂预案（条件分支/多Agent交互）。
    - 线性预案 → LangGraph/Smolagents自动执行；
    - 复杂预案 → AutoGen子智能体多轮协作。
4. **统一执行引擎接口**：支持LangGraph（工程落地）和Smolagents（轻量测试）。
5. **标准化报告**：输出报告包含背景、数据来源、公式推导、结论与建议。
6. **工程可控**：支持预案库管理、版本控制、执行追溯和人机协同。

---

## 2. 总体目标

- **技术目标**：

    - 建立统一**预案 DSL（Plan JSON Schema）**，作为"预案即程序"的统一抽象；
    - 构建**预案解析器**，将自然语言文本自动转换为 Plan JSON；
    - 构建双执行器：LangGraph（稳定部署）和 Smolagents（快速实验），支撑线性预案执行；
    - 搭建**AutoGen Controller**，负责预案选择、复杂度判断、执行路由和结果汇总；
    - 建立**Decision Agent**，输出符合调度员要求的透明、可追溯报告。
- **业务目标**：
    - 在典型场景（如设备故障直流限额）实现**输入告警 → 自动生成执行步骤 → 调用工具 → 生成报告**的全链路闭环；
    - 在特定时间内覆盖 80% 以上标准预案。

---

## 3. 总体架构

### 3.1 架构分层

```java
用户输入 (告警/场景)
        ↓
AutoGen Controller (中控智能体)
   ├─ 预案解析器 (文本 → Plan JSON)
   ├─ 复杂度判断
   │    • 线性简单 → LangGraph Executor
   │    • 线性简单 → Smolagents Executor
   │    • 复杂分支 → AutoGen Sub-agents
   ↓
执行器 (LangGraph / Smolagents)
        ↓
执行结果 (变量值 + 公式推导 + 工具来源)
        ↓
Decision Agent (生成Markdown/JSON报告)
        ↓
调度员查看/确认
```

### 3.2 端到端执行流程

1. **输入**：
    - 预案文本（如"设备故障直流限额计算预案"）
    - 场景描述（如"天哈一线停运，影响天中直流"）
2. **AutoGen Controller**：
    - 调用预案解析器 → 得到 Plan JSON
    - 判断为线性预案 → 路由到 LangGraph
3. **执行器**：
    - LangGraph 根据 Plan JSON 生成 StateGraph
    - 依次执行 rag/tool/compute 步骤
    - 收集所有中间变量和最终结果
4. **Decision Agent**：
    - 格式化输出报告，包含背景、数据来源、公式推导、结论与建议
5. **用户得到报告**：
    - 示例："直流限额=2800 MW，约束主因=受端限额"

### 3.3 模块职责

- **预案解析器**：抽取步骤、变量、公式，并转换为Plan JSON格式。
- **LangGraph Executor**：将Plan JSON转换为StateGraph，按顺序执行rag/tool/compute节点。
- **Smolagents Executor**：将Plan JSON转换为工具链，实现轻量级执行。
- **AutoGen Controller**：负责路由与调度，调用解析器和执行器，并汇总结果。
- **Decision Agent**：生成标准化报告。
- **工具层 (Tools API)**：提供统一数据接口，包括送端限额、受端限额、换流器参数、断面功率等。
- **RAG 层**：索引规程与标准文档，用于规则判定（如送/受端判定）。

---

## 4. 预案写作规范

### 4.1 注释区说明（放在预案开头）

```text
# =========================================================
# 电网调度标准预案写作规范
#
# 1. 每个步骤必须编号（1,2,3,…），并包含【输入】和【输出】。
# 2. 所有计算变量必须在“变量定义”部分定义，并保持与公式一致。
# 3. 每个变量需注明单位（MW, kA, 台, …）。
# 4. 计算公式必须用 LaTeX 或清晰的数学表达式表示。
# 5. 数据来源只需描述，不必写具体工具名，由系统自动映射。
# =========================================================
```

### 4.2 正文区结构

- **预案标题**
- **步骤**（自然语言描述 + 输入/输出）
- **变量定义**（符号、单位、公式）

---

### 4.3 预案示例（合规范版）

```ruby
# =========================================================
# 电网调度标准预案写作规范
# 1. 每个步骤必须编号（1,2,3,…），并包含【输入】和【输出】。
# 2. 所有计算变量必须在“变量定义”部分定义，并保持与公式一致。
# 3. 每个变量需注明单位（MW, kA, 台, …）。
# 4. 计算公式必须用 LaTeX 或清晰的数学表达式表示。
# =========================================================

设备故障直流限额计算预案

步骤：
1. 查询停运的<设备>影响的<直流线路>，并判定其位于送端还是受端。
   输入：<设备>
   输出：dc_line, side_info

2. 计算电网运行方式：送端限额与受端限额的最小值。
   输入：P_max_send, P_max_receive
   输出：P_max_net

3. 计算设备传输能力：换流器运行容量 × 电流限额 × 换流器个数。
   输入：P_max_convert, F_current, N_convert
   输出：P_dcsystem

4. 计算设备故障直流限额：min(P_max_net, P_dcsystem)。
   输入：P_max_net, P_dcsystem
   输出：P_max_device

变量定义：
- 送端电网限额：$P_{max\_send}$ （MW）
- 受端电网限额：$P_{max\_receive}$ （MW）
- 电网运行方式传输限额：$P_{max\_net} = \min(P_{max\_send}, P_{max\_receive})$
- 换流器运行容量：$P_{max\_convert}$ （MW）
- 电流限值：$F_{current}$ （kA）
- 换流器个数：$N_{convert}$ （count）
- 设备传输能力：$P_{dcsystem} = P_{max\_convert} \times F_{current} \times N_{convert}$
- 设备故障直流限额：$P_{max\_device} = \min(P_{max\_net}, P_{dcsystem})$
```

---

## 5. Plan JSON Schema（解析器输出）

- **输入**：上面的预案文本
- **输出**：结构化 Plan JSON（rag + tool + compute 步骤链）
- **作用**：供 LangGraph/Smolagents 执行器直接使用

示例片段：

```json
{
  "plan_id": "dc_limit_fault",
  "description": "设备故障直流限额计算预案",
  "steps": [
    {"id":"step1","type":"rag","query":"判定停运设备影响直流线路送/受端","inputs":{"device":"<设备>","line":"<直流线路>"},"output":["side_info"]},
    {"id":"tool_send","type":"tool","tool_name":"query_send_limit","inputs":{"line":"{hvdc_line}"},"output":["P_max_send"]},
    {"id":"tool_recv","type":"tool","tool_name":"query_recv_limit","inputs":{"line":"{hvdc_line}"},"output":["P_max_receive"]},
    {"id":"compute_net","type":"compute","formula":"min(P_max_send,P_max_receive)","inputs":{"P_max_send":"{P_max_send}","P_max_receive":"{P_max_receive}"},"output":["P_max_net"]},
    {"id":"compute_final","type":"compute","formula":"min(P_max_net,P_dcsystem)","inputs":{"P_max_net":"{P_max_net}","P_dcsystem":"{P_dcsystem}"},"output":["P_max_device"]}
  ]
}
```

---

## 6. 工程化设计要点

1. **Tools API**
    - 统一输入/输出格式：`{value, unit, source, timestamp}`
    - 集成鉴权、日志、缓存和重试机制
2. **可观测性**
    - 预案解析日志（记录步骤、变量和公式抽取）
    - 执行器日志（记录工具调用和公式代入）
    - 报告生成日志（记录数值推导和数据来源）
3. **人机协同**
    - 解析器遇到未知步骤时，提示调度员确认
    - 工具无返回值时，提供兜底结果并添加警告标记
4. **预案库管理**
    - 预案文件采用版本化存储（Git/数据库）
    - 每次执行时记录预案版本号、输入场景和输出报告

---

## 7. 路线图

- **阶段一（MVP）**
    - 接入典型预案（直流限额），集成2–3个真实工具接口，完成解析→执行→报告全流程验证
- **阶段二（扩展）**
    - 扩展至断面校核、备用容量等常见预案
    - 提升解析器鲁棒性（Schema 校验 + Few-shot 提示）
- **阶段三（生产化）**
    - 实现全量预案覆盖
    - 部署监控与回归测试体系
    - 执行灰度上线策略
- **阶段四（智能化升级）**
    - 通过 SFT/AgenticRL 优化 Controller 智能决策能力
    - 实现新增预案自动适配，减少人工干预

---

## 8. 方案价值

- **面向调度员友好**：仅需以自然语言编写预案并遵循注释规范，无需编程知识。
- **自动化执行**：系统自动完成文本解析、转换为JSON DSL，并通过LangGraph/Smolagents执行全流程。
- **透明可追溯**：决策报告详细记录背景信息、计算公式和数据来源，便于后续审计。
- **易于扩展**：增加新预案只需填写标准模板，无需编写代码。
- **工程化可控**：集成版本管理、日志记录和人工确认机制，充分满足电网调度场景的安全性要求。